using System;
using System.Linq;
using System.Collections.Generic;
using Mono.Cecil;
using Mono.Cecil.Cil;
using Mono.Cecil.Rocks;

class ProtobufDecompiler {
	public void ProcessTypes(IEnumerable<TypeDefinition> types) {
		if (types.Any(x => x.Name == "IProtoBuf")) {
			Console.WriteLine("detected SilentOrbit protos");
			processor = new SilentOrbitTypeProcessor();
		} else {
			// We could detect based on subclassing GeneratedMessage*, but no
			// point unless we have more than 2 types of protogens.
			Console.WriteLine("assuming Google protos");
			processor = new GoogleTypeProcessor();
		}

		var packages = new Dictionary<string, List<ILanguageNode>>();
		foreach (var type in types) {
			processor.Process(type);
		}

		// TODO: create files.
	}

	public void WriteProtos() {}

	TypeProcessor processor;
	List<FileNode> files = new List<FileNode>();
}

// Represents a type capable of processing c# types generated by protoc and
// decompiling them into protobuf type nodes.
abstract class TypeProcessor {
	public abstract void Process(TypeDefinition type);

	public Dictionary<string, List<ILanguageNode>> PackageNodes { get; set; }

	public TypeProcessor() {
		PackageNodes = new Dictionary<string, List<ILanguageNode>>();
	}

	protected void AddPackageNode(string package, ILanguageNode node) {
		if (!PackageNodes.ContainsKey(package)) {
			PackageNodes[package] = new List<ILanguageNode>();
		}
		PackageNodes[package].Add(node);
	}
}

// Processes protobuf types generated by SilentOrbit's protobuf implementation,
// found at <https://github.com/hultqvist/ProtoBuf>
class SilentOrbitTypeProcessor : TypeProcessor {
	public override void Process(TypeDefinition type) {
		// Since a protobuf package corresponds to a C# namespaces, no generated
		// protobuf classes exist in the root namespace.
		if (type.Namespace.Length == 0) {
			return;
		}

		if (type.IsEnum) {
			ProcessEnum(type);
			return;
		}

		if (type.Interfaces.Any(r => r.Name == "IProtoBuf")) {
			ProcessMessage(type);
			return;
		}

		// These aren't actually generated by SilentOrbit's code, but they're
		// defined in protobuf.
		if (type.Interfaces.Any(r => r.Name == "ServiceDescriptor")) {
			// However, since we can use protobins for everything in the bnet
			// package, services included, this isn't worth implementing.
			return;
		}
	}

	void ProcessEnum(TypeDefinition type) {}

	void ProcessMessage(TypeDefinition type) {
		var package = type.Namespace;
		var result = new MessageNode(type.Name);
		var deserializeWalker = new MethodWalker(type.Methods.First(m =>
			m.Name == "Deserialize" && m.Parameters.Count == 3));
		deserializeWalker.OnStore = store => {
			Console.WriteLine("store: {0} = {1}",
				store.Field.Name, store.Argument);
		};
		deserializeWalker.OnCall = info => {
			Console.WriteLine("call: {0}\nconditions: {1}", info.String, String.Join(", ", info.Conditions));
		};
		deserializeWalker.Walk();
		var serializeWalker = new MethodWalker(type.Methods.First(m =>
			m.Name == "Serialize" && m.Parameters.Count == 2));
		serializeWalker.OnStore = store => {
			Console.WriteLine("store: {0} = {1}",
				store.Field.Name, store.Argument);
		};
		serializeWalker.OnCall = info => {
			Console.WriteLine("call: {0}\nconditions: {1}", info.String, String.Join(", ", info.Conditions));
		};
		serializeWalker.Walk();

		AddPackageNode(package, result);
	}
}

// Processes protobuf types generated by the protobuf-csharp-port project,
// which is currently owned by Google and was originally created by Jon Skeet.
class GoogleTypeProcessor : TypeProcessor {
	public override void Process(TypeDefinition type) {
		return;
	}
}

// Explore the code paths of a method and generate events for every possible
// call generated by the method, including data on what the call arguments are
// and what conditions were necessary to reach the call instruction.  Emits
// similar events for non-local stores.
public class MethodWalker {
	public Action<CallInfo> OnCall;
	public Action<StoreInfo> OnStore;

	public enum Comparison {
		Equal,
		Inequal,
		GreaterThan,
		GreaterThanEqual,
		IsTrue,
		IsFalse
	}

	public class Condition {
		public int Until { get; set; }
		public string Lhs { get; set; }
		public string Rhs { get; set; }
		public Comparison Cmp { get; set; }

		public Condition(int until, string lhs, Comparison cmp, string rhs = null) {
			Until = until;
			Lhs = lhs;
			Rhs = rhs;
			Cmp = cmp;
		}

		public override string ToString() {
			var cmpStr = "";
			switch (Cmp) {
			case Comparison.Equal:            cmpStr = "=="; break;
			case Comparison.Inequal:          cmpStr = "!="; break;
			case Comparison.GreaterThan:      cmpStr = ">"; break;
			case Comparison.GreaterThanEqual: cmpStr = ">="; break;
			case Comparison.IsTrue:           cmpStr = "== true"; break;
			case Comparison.IsFalse:          cmpStr = "== false"; break;
			}
			return String.Format("{0} {1}{2}", Lhs, cmpStr,
				String.IsNullOrEmpty(Rhs) ? "" : " " + Rhs);
		}
	}

	public class CallInfo {
		public List<Condition> Conditions { get; set; }
		public MethodReference Method { get; set; }
		public List<string> Arguments { get; set; }
		public string String { get; set; }
	}

	public class StoreInfo {
		public List<Condition> Conditions { get; set; }
		public FieldReference Field { get; set; }
		public string Argument { get; set; }
	}

	HashSet<int> Explored = new HashSet<int>();
	MethodDefinition Method;
	public MethodWalker(MethodDefinition method) {
		Method = method;
		Method.Body.SimplifyMacros();
	}

	class OpState {
		public int Offset { get; set; }
		public List<object> Stack { get; set; }
		public List<Condition> Conditions { get; set; }

		public OpState() {
			Offset = 0;
			Stack = new List<object>();
			Conditions = new List<Condition>();
		}

		public OpState(int offset, List<object> stack, List<Condition> conditions) {
			Offset = offset;
			Stack = stack;
			Conditions = conditions;
		}
	}

	List<OpState> processingQueue = new List<OpState>();

	public void Walk() {
		processingQueue.Add(new OpState());
		
		while (processingQueue.Count > 0) {
			processingQueue.Sort((a, b) => a.Conditions.Count - b.Conditions.Count);
			processingQueue.Sort((a, b) => a.Offset - b.Offset);
			var next = processingQueue.First();
			processingQueue.Remove(next);
			Explore(next.Offset, next.Stack, next.Conditions);
		}
	}

	void Explore(int offset, List<object> stack, List<Condition> conditions) {
		var ins = Method.Body.Instructions.First(o => o.Offset == offset);
		if (Explored.Contains(ins.Offset)) return;
		Explored.Add(ins.Offset);
		var deadConditions = new List<Condition>();
		foreach (var cond in conditions) {
			if (cond.Until == offset) {
				deadConditions.Add(cond);
			}
		}
		foreach (var deadCond in deadConditions) {
			conditions.Remove(deadCond);
		}

		switch (ins.OpCode.Code) {
		case Code.Ldc_I4:
		case Code.Ldc_R4:
		case Code.Ldstr:
			stack.Add(ins.Operand);
			break;
		case Code.Ldloca:
			stack.Add("&" + (ins.Operand as VariableReference).ToString());
			break;
		case Code.Ldloc:
			stack.Add((ins.Operand as VariableReference).ToString());
			break;
		case Code.Ldfld:
			var field = String.Format("{0}.{1}",
				stack.Pop(), (ins.Operand as FieldReference).Name);
			stack.Add(field);
			break;
		case Code.Ldsfld:
			stack.Add((ins.Operand as FieldReference).FullName);
			break;
		case Code.Ldarg: {
			var idx = (ins.Operand as ParameterReference).Index;
			if (idx == -1) {
				stack.Add("this");
			} else {
				stack.Add(String.Format("arg{0}", idx));
			}
		} break;
		case Code.Ldelem_Ref: {
			var idx = stack.Pop();
			var arr = stack.Pop();
			stack.Add(String.Format("{0}[{1}]", arr, idx));
		} break;
		case Code.Newobj:
			stack.Add(String.Format("new {0}()",
				(ins.Operand as MethodReference).DeclaringType.Name));
			break;
		case Code.Brfalse: {
			var lhs = stack.Pop().ToString();
			var tgt = (ins.Operand as Instruction).Offset;
			var cond = new Condition(tgt, lhs, Comparison.IsFalse);
			var ncond = new Condition(tgt, lhs, Comparison.IsTrue);
			Branch(tgt, stack, conditions, cond, ncond); 
		} break;
		case Code.Brtrue: {
			var lhs = stack.Pop().ToString();
			var tgt = (ins.Operand as Instruction).Offset;
			var cond = new Condition(tgt, lhs, Comparison.IsTrue);
			var ncond = new Condition(tgt, lhs, Comparison.IsFalse);
			Branch(tgt, stack, conditions, cond, ncond);
		} break;
		case Code.Beq:
		case Code.Bne_Un:
		case Code.Ble:
		case Code.Bge:
		case Code.Blt:
		case Code.Bgt: {
			var lhs = stack.Pop().ToString();
			var rhs = stack.Pop().ToString();
			var tgt = (ins.Operand as Instruction).Offset;
			Condition cond = null, ncond = null;
			switch (ins.OpCode.Code) {
			case Code.Beq:
				cond = new Condition(tgt, lhs, Comparison.Equal, rhs);
				ncond = new Condition(tgt, lhs, Comparison.Inequal, rhs);
				break;
			case Code.Bne_Un:
				cond = new Condition(tgt, lhs, Comparison.Inequal, rhs);
				ncond = new Condition(tgt, lhs, Comparison.Equal, rhs);
				break;
			case Code.Ble:
				// x <= y --> y >= x; !(x <= y) --> x > y
				cond = new Condition(tgt, rhs, Comparison.GreaterThanEqual, lhs);
				ncond = new Condition(tgt, lhs, Comparison.GreaterThan, rhs);
				break;
			case Code.Bge:
				cond = new Condition(tgt, lhs, Comparison.GreaterThanEqual, rhs);
				// !(x >= y) --> y > x
				ncond = new Condition(tgt, rhs, Comparison.GreaterThan, lhs);
				break;
			case Code.Blt:
				// x < y --> y > x; !(x < y) --> x >= y
				cond = new Condition(tgt, rhs, Comparison.GreaterThan, lhs);
				ncond = new Condition(tgt, lhs, Comparison.GreaterThanEqual, rhs);
				break;
			case Code.Bgt:
				// !(x > y) --> y >= x
				cond = new Condition(tgt, lhs, Comparison.GreaterThan, rhs);
				ncond = new Condition(tgt, rhs, Comparison.GreaterThanEqual, lhs);
				break;
			}
			Branch(tgt, stack, conditions, cond, ncond);
		} break;
		case Code.Br:
			Explore((ins.Operand as Instruction).Offset, stack, conditions);
			return;
		case Code.Stfld:
			var arg = stack.Pop().ToString();
			if (OnStore == null) break;
			OnStore(new StoreInfo {
				Conditions = new List<Condition>(conditions),
				Field = ins.Operand as FieldReference,
				Argument = arg,
			});
			break;
		case Code.Call:
		case Code.Callvirt: {
			var mr = ins.Operand as MethodReference;
			var args = new List<string>();
			for (var i = 0; i < mr.Parameters.Count; i++) {
				args.Add(stack.Pop().ToString());
			}
			if (mr.HasThis) {
				args.Add(stack.Pop().ToString());
			}
			var callString = String.Format("{0}.{1}({2})",
				mr.HasThis ? args.Last() : mr.DeclaringType.Name,
				mr.Name,
				String.Join(", ",
					mr.HasThis ? args.Take(args.Count - 1) : args));
			if (mr.ReturnType.FullName != "System.Void") {
				stack.Add(callString);
			}
			if (OnCall == null) break;
			OnCall(new CallInfo {
				Conditions = new List<Condition>(conditions),
				Method = mr,
				Arguments = args,
				String = callString
			});
		} break;
		}

		if (ins.Next != null) {
			processingQueue.Add(new OpState(ins.Next.Offset, stack, conditions));
		}
	}

	void Branch(int offset, List<object> stack, List<Condition> conditions,
		Condition conditionTaken, Condition conditionNotTaken) {

		var newConds = new List<Condition>(conditions);
		newConds.Add(conditionTaken);
		conditions.Add(conditionNotTaken);
		processingQueue.Add(new OpState(offset,
			new List<object>(stack), newConds));
	}
}

public static class CollectionExtensions {
	// Because a List<T> is a more versatile stack than Stack<T>.  Mainly for
	// ease of cloning.
	public static T Pop<T>(this List<T> stack) {
		var last = stack.Count - 1;
		var result = stack[last];
		stack.RemoveAt(last);
		return result;
	}
}
